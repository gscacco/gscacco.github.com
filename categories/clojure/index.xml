<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Clojure on G.Scacco</title>
    <link>http://gscacco.github.io/categories/clojure/</link>
    <description>Recent content in Clojure on G.Scacco</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>it-it</language>
    <lastBuildDate>Tue, 19 May 2015 14:23:54 +0200</lastBuildDate>
    <atom:link href="http://gscacco.github.io/categories/clojure/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Project Euler - Problema 2</title>
      <link>http://gscacco.github.io/post/peuler2/</link>
      <pubDate>Tue, 19 May 2015 14:23:54 +0200</pubDate>
      
      <guid>http://gscacco.github.io/post/peuler2/</guid>
      <description>

&lt;h2 id=&#34;definizione:8a89e71cf793842aee17202ce09111e2&#34;&gt;Definizione&lt;/h2&gt;

&lt;p&gt;Il problema numero due ha la seguente definizione:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In italiano:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Ciascun nuovo termine della serie di Fibonacci è generato aggiungendo i due precedenti termini. Iniziando con i 1 e 2, i primi 10 termini saranno:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Considerando i termini della serie di Fibinacci non superiori a quattro milioni, trovare la somma dei termini pari.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;funzioni-base:8a89e71cf793842aee17202ce09111e2&#34;&gt;Funzioni base&lt;/h2&gt;

&lt;p&gt;L&amp;rsquo;idea è quella di definire una funzione che dati una serie di N numeri di Fibonacci, restituisca una nuova serie formata dai precedenti N numeri con l&amp;rsquo;aggiunta di un nuovo termine; il nuovo termine sarà calcolato sommando gli ultimi due.&lt;/p&gt;

&lt;p&gt;La funzione clojure, quindi, sarà:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn fibonacci-step [xs]
  (let [prossimo-termine (+ (first xs) (second xs))]
    (conj xs prossimo-termine)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La funzione appena definita avrà in input una lista di termini e restituirà una nuova lista formata dalla vecchia più il prossimo termine.&lt;/p&gt;

&lt;p&gt;La funzione &lt;em&gt;let&lt;/em&gt; utilizzata ha la seguente forma: (let [bindings*] exprs*). Il suo scopo è quello di valutare le espressioni in un contesto nel quale è stato definito un insieme di bindings.&lt;/p&gt;

&lt;p&gt;In questo caso, quindi, abbiamo creato un binding di nome &lt;em&gt;prossimo-termine&lt;/em&gt; con valore la somma del primo e del secondo elemento della lista.&lt;/p&gt;

&lt;p&gt;Proviamo ad applicare la funziona appena definita:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user =&amp;gt; (fibonacci-step &#39;(2 1))
(3 2 1)
user =&amp;gt; (fibonacci-step (fibonacci-step &#39;(2 1))))
(5 3 2 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Come possiamo vedere la nostra lista cresce a sinistra con i nuovi termini calcolati.&lt;/p&gt;

&lt;h2 id=&#34;ricorsione:8a89e71cf793842aee17202ce09111e2&#34;&gt;Ricorsione&lt;/h2&gt;

&lt;p&gt;A questo punto possiamo pensare di creare una sequenza di &lt;em&gt;applicazioni di funzione&lt;/em&gt; così fatta:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x, f(x), f(f(x)), ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Per questo ci viene in aiuto la funzione iterate. La sua definizione è la seguente:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(iterate f x)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Il ritorno è una sequenza lazy (letteralmente &lt;em&gt;pigra&lt;/em&gt;), cioè una lista in cui i singoli elementi non vengono calcolati subito ma solo se e quando servono veramente. La lista lazy ritornata ha una sequenza infinita di termini. Possiamo concretizzare la lista prendendo un certo numero di elementi; le funzioni utilizzate a tale scopo sono take e take-while.&lt;/p&gt;

&lt;p&gt;Ad esempio:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user =&amp;gt; (take 2 (iterate fibonacci-step &#39;(2 1)))
((2 1) (3 2 1))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La funzione take-while prende in input un predicato (il predicato è una funzione che torna un booleano). Ad esempio:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user =&amp;gt; (take-while #(&amp;lt;= (count %) 6) (iterate fibonacci-step &#39;(2 1)))
((2 1) (3 2 1) (5 3 2 1) (8 5 3 2 1) (13 8 5 3 2 1))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nell&amp;rsquo;esempio il predicato torna true solo se il numero dei termini della i-esima applicazione è &amp;lt;= 6. Se il predicato fosse sempre true l&amp;rsquo;esecuzione non avrebbe mai fine.&lt;/p&gt;

&lt;h2 id=&#34;finalizzazione:8a89e71cf793842aee17202ce09111e2&#34;&gt;Finalizzazione&lt;/h2&gt;

&lt;p&gt;Gli ingredienti per la finalizzazione sono i seguenti:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;La funzione fibonacci-step&lt;/li&gt;
&lt;li&gt;La funzione iterate&lt;/li&gt;
&lt;li&gt;La funzione take-while&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;e possiamo utilizzarli all&amp;rsquo;interno della funzione peuler2:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn peuler2 []
  (let [mf (fn [xs] (&amp;lt;= (first xs) 4000000))]
    (-&amp;gt;&amp;gt; (iterate fibonacci-step &#39;(2 1))
         (take-while mf)
         (last)
         (filter even?)
         (reduce +))))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;note:8a89e71cf793842aee17202ce09111e2&#34;&gt;Note&lt;/h2&gt;

&lt;p&gt;Vorrei evidenziare l&amp;rsquo;uso della funzione -&amp;gt;&amp;gt;. La sua definizione formale è la seguente: (-&amp;gt;&amp;gt; x &amp;amp; forms). Il suo scopo è quello di appendere il parametro x alla fine della prima forma. Successivamente, il risultato sarà appeso alla fine delle altre forme.&lt;/p&gt;

&lt;p&gt;Con un esempio:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user =&amp;gt; (-&amp;gt;&amp;gt; (range)
              (filter even?)
              (take 6)
              (reduce +))
30
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Il risultato è la somma dei primi 6 numeri pari (0 2 4 6 8 10).&lt;/p&gt;

&lt;p&gt;La forma -&amp;gt;&amp;gt; è molto utile per semplificare la lettura del codice; per ottenere lo stesso risultato senza -&amp;gt;&amp;gt; avremmo dovuto scrivere:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user =&amp;gt; (reduce + (take 6 (filter even? (range))))
30
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Project Euler - Problema 1</title>
      <link>http://gscacco.github.io/post/peuler1/</link>
      <pubDate>Tue, 12 May 2015 14:31:23 +0200</pubDate>
      
      <guid>http://gscacco.github.io/post/peuler1/</guid>
      <description>

&lt;h1 id=&#34;project-euler:4267fac4619cf7d01f2cdbc9ec8918bf&#34;&gt;Project Euler&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://projecteuler.net/&#34;&gt;Project Euler&lt;/a&gt; è un interessantissimo sito web contenente una raccolta di problemi. Si tratta di sfide matematiche ed informatiche da risolvere tramite l&amp;rsquo;uso di un linguaggio di programmazione a scelta. Molti sono gli utenti registrati che si sono impegnati nelle varie soluzioni e nei più disparati linguaggi: si va dal linguaggio macchina a Java, dal c++ al lisp, etc.&lt;/p&gt;

&lt;p&gt;Vorrei proporvi in questo post (e spero in altri) le mie soluzioni in clojure.&lt;/p&gt;

&lt;p&gt;Darò per scontata una conoscenza base del linguaggio &lt;a href=&#34;http://clojure.org/&#34;&gt;clojure&lt;/a&gt; e la conoscenza del tool &lt;a href=&#34;http://leiningen.org/&#34;&gt;Leingen&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;multipli-di-3-e-5:4267fac4619cf7d01f2cdbc9ec8918bf&#34;&gt;Multipli di 3 e 5&lt;/h2&gt;

&lt;p&gt;Il &lt;a href=&#34;https://projecteuler.net/problem=1&#34;&gt;problema&lt;/a&gt; è così definito:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
Find the sum of all the multiples of 3 or 5 below 1000.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In italiano:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Se elenchiamo tutti i numeri naturali inferiori a 10 che sono multipli di 3 o di 5 otteniamo 3, 5, 6 e 9. La somma di questi multipli è 23.
Trova la somma di tutti i multipli di 3 e 5 inferiori a 1000.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Lanciamo la consolle repl di clojure tramite il comando:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lein repl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Possiamo verificare se un numero è multiplo di un altro in clojure utilizzando la funzione &lt;em&gt;rem&lt;/em&gt; (resto della divisione intera).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user=&amp;gt; (rem 15 5)
0
user=&amp;gt; (rem 15 6)
3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nel primo caso essendo 15 multiplo di 5 il risultato è 0; nel secondo 15 non è multiplo di 6 ed il risultato è 3 (il resto della divisione intera tra 15 e 6).&lt;/p&gt;

&lt;p&gt;In clojure esiste il predicato &lt;em&gt;zero?&lt;/em&gt; che torna true solo se il suo argomento è 0, false altrimenti:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user=&amp;gt; (zero? 0)
true
user=&amp;gt; (zero? 9)
false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A questo punto possiamo definire la nostra prima funzione:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user=&amp;gt; (defn multiplo? [n d] (zero? (rem n d)))
user=&amp;gt; (multiplo? 15 5)
true
user=&amp;gt; (multiplo? 15 6)
false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;E per concludere:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user=&amp;gt; (defn multiplo-di-tre-o-cinque? [n] (or (multiplo? n 3) (multiplo? n 5)))
user=&amp;gt; (multiplo-di-tre-o-cinque? 6)
true
user=&amp;gt; (multiplo-di-tre-o-cinque? 10)
true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Possiamo generare la lista dei numeri interi utilizzando la funzione &lt;em&gt;range&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user=&amp;gt; (range 2 10)
(2 3 4 5 6 7 8 9)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;e filtrare in base al nostro predicato &lt;em&gt;multiplo-di-tre-o-cinque?&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user=&amp;gt; (filter multiplo-di-tre-o-cinque? (range 2 10))
(3 5 6 9)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;fare la somma di una lista è semplice:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user=&amp;gt; (reduce + (filter multiplo-di-tre-o-cinque? (range 2 10)))
23
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In questo modo abbiamo riottenuto il valore proposto nel caso semplice nella definizione del problema. Meglio definire, una funzione:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user=&amp;gt; (defn eulero-p1 [max] (reduce + (filter multiplo-di-tre-o-cinque? (range 2 max))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Siamo arrivati alla fine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user=&amp;gt; (eulero-p1 1000)
233168
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Quindi, in sintesi:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn- multiplo? [n d]
  (zero? (rem n d)))

(defn- multiplo-di-tre-o-cinque? [n]
  (or
   (multiplo? n 3)
   (multiplo? n 5)))

(defn eulero-p1 [max]
  (reduce + (filter multiplo-di-tre-o-cinque? (range 2 max))))

(eulero-p1 1000)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>